# 第九章：泛型 Generics

## 9.4 泛型的工作方式(How Generics Work)
本小节讲了一些关于泛型```底层```的知识点和一些```特殊情况下```的使用。可以当做扩充知识面去学习。

#### 我们先看看一个最简单的泛型函数的底层实现

    func min<T: Comparable>(_ x: T, _ y: T) -> T { 
        return y<x ? y:x
    }

编译器无法为这个函数```直接生产代码```，原因如下：

1.编译器不知道T的```变量大小```
    
2.编译器不知道需要调用的```<```函数是否有重载，所以也不知道需要调用的```函数的地址```
    
swift 为函数引入了一套间接的```中间层```来解决这个问题，引入了一个容器，编译器会把泛型放到这个容器中
对于泛型的参数，编译器还维护了一个或者多个```目击表(witness table)```，包括一个```值目击表```，以及每个协议约束的```协议目击表```。 这些表将运行时的函数```动态派发```到正确的实现中。 表里实际上放的都是```指针```。同时还记录了```类型大小和对齐方式```。


### 泛型特化

光看泛型特化这个词很难理解它的用法和意思，后面我们会讲。

使用泛型特化的原因：
大家先了解一个swift的设计目标： ```"编译一次，动态派发"```
swift 泛型API只需要知道泛型函数或者类型的声明，并```不关心实现```。
所以结果的代码不是那么直接。这会导致```运行时性能低```

swift库中有很多泛型的使用，性能开销很容易叠加。

这里就引入了```泛型特化(generic specialization)``` 来避免这个不必要的开销。
泛型特化的本质：
编译器按照```具体的参数类型```将函数进行```复制```。
文章一开始的例子中，可能针对于Int的参数类型特化出一个方法是这样的

    func min(_ x: Int, _ y: Int) -> Int { 
        returny<x?y:x
    }

这个时候你就大概知道```泛型特化```的意思就是将泛型针对于不同的类型的调用而生成具体的方法。

泛型特化不仅能```去掉虚拟派发的开销```， 还可以让```内联```等进一步优化成为可能

泛型特化的决定在```编译时```进行。特化的参数类型很可能是你```经常使用```的具体类型，
如果你经常使用Int 只用过一次float  那么就会特化出上面的函数。

缺点：泛型定义和调用在```同一个文件中```时，泛型特化才能工作，只能在模块内使用😅(标准库中的泛型方法除外，因为标准库的定义对于所有模块都是可见的)


### 全模块优化

因为泛型特化是一个很严重的限制，所以编译器引入了一个标志来启用```全模块优化```

可以通过向 swiftc 传递 -whole-module-optimization 来开启全模块优化

一般都是在```发布版本中```进行这项操作，

```优点：```大幅度提升性能
```缺点：```会带来更长的编译时间


#### @_specialize 关键字

[@_specialize](https://github.com/apple/swift/blob/master/docs/Generics.rst#specialization) 是一个```非官方```的标签，计划将来会引入到标准库中。
作用：将你的泛型代码进行指定版本的特化，使其在```其他模块中```也可用。(你必须要指明想要进行特化的类型列表)
使用如下：

    @_specialize(exported: true, where T == Int)
    @_specialize(exported: true, where T == String) 
    public func min<T: Comparable>(_ x: T, _ y: T) -> T {
        returny<x?y:x 
    }
    
 2019.4.20：
    泛型特化的更多相关知识点这里推荐medium的文章[Generic Specialization of functions in Swift ](https://medium.com/@lucianoalmeida1/specialization-of-generic-functions-in-swift-786b64ac3442) 
    

over~

