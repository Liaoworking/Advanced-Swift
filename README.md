# Advanced-Swift

> The only way to learn a new programming language is by writing programs in it.
> 学习一种新的编程语言的唯一方法，就是用它编写程序。
> <p align="right">--- Dennis Ritchie</p>



Notes of Advanced Swift. 《swift进阶》学习笔记, 持续更新中。。。  swift 5.0 to swift 5.3ing.




### 第一章 介绍
##### 一本书的第一章都是一些```博大精深```的东西，讲了很多swift这门语言的一些```基础概念```和```特点```。在以后的章节里会对应一一讲解。略略略。。。


### 第二章 ：内建集合类型
#### [2.1数组](https://github.com/Liaoworking/Advanced-Swift/blob/master/第二章：内建集合类型/2.1%20数组.md)

#### [2.2字典](https://github.com/Liaoworking/Advanced-Swift/blob/master/第二章：内建集合类型/2.2%20字典.md)

#### [2.3 set 2.4 Range](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%86%85%E5%BB%BA%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/2.3%20set%202.4%20Range%20.md)

### 第三章 : 集合类型协议
#### [3.1 序列](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/3.1%20%E5%BA%8F%E5%88%97.md)


#### [3.2集合类型](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/3.2%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.md)

#### [3.3索引](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/3.3%E7%B4%A2%E5%BC%95.md)

#### [3.4切片](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/3.4%E5%88%87%E7%89%87.md)

#### [3.5专门的集合类型](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8D%8F%E8%AE%AE/3.5%E4%B8%93%E9%97%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B.md)

### 第四章 ： 可选值

#### [4.1---4.3 序列-魔法数问题-可选值概览](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%8F%AF%E9%80%89%E5%80%BC/4.1_3%20%E5%BA%8F%E5%88%97_%E9%AD%94%E6%B3%95%E6%95%B0%E9%97%AE%E9%A2%98_%E5%8F%AF%E9%80%89%E5%80%BC%E6%A6%82%E8%A7%88.md)

#### [4.4 强制解包的时机](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%8F%AF%E9%80%89%E5%80%BC/4.4%20%E5%BC%BA%E5%88%B6%E8%A7%A3%E5%8C%85%E7%9A%84%E6%97%B6%E6%9C%BA.md)

#### [4.5 多灾多难的隐式可选值](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%8F%AF%E9%80%89%E5%80%BC/4.5%20%E5%A4%9A%E7%81%BE%E5%A4%9A%E9%9A%BE%E7%9A%84%E9%9A%90%E5%BC%8F%E5%8F%AF%E9%80%89%E5%80%BC.md)

### 第五章：结构体和类

#### [5.1 值类型---5.2 可变性](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/5.1_2%E5%80%BC%E7%B1%BB%E5%9E%8B_%E5%8F%AF%E5%8F%98%E6%80%A7.md)

#### [5.3 结构体](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/5.3%20%E7%BB%93%E6%9E%84%E4%BD%93.md)

#### [5.4 写时复制](https://github.com/Liaoworking/Advanced-Swift/blob/master/第五章：结构体和类/5.4%20写时复制.md)

#### [5.5_6 闭包和可变性_内存](https://github.com/Liaoworking/Advanced-Swift/blob/master/第五章：结构体和类/5.5_6%20闭包和可变性_内存.md)

#### [5.7_8 闭包和内存](https://github.com/Liaoworking/Advanced-Swift/blob/master/第五章：结构体和类/5.7_8%20闭包和内存.md)


### 第六章：函数

#### [6 函数(总体介绍)](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%87%BD%E6%95%B0/6.%20%E5%87%BD%E6%95%B0(%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D).md)

#### [6.1 函数的灵活性](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%87%BD%E6%95%B0/6.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7.md)

#### [6.2 局部函数和变量捕获](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%87%BD%E6%95%B0/6.2%20%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7.md)

#### [6.3 函数作为代理](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%87%BD%E6%95%B0/6.3%20%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E4%BB%A3%E7%90%86%20function%20as%20delegate.md)

#### [6.4 inout参数和可变方法](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%87%BD%E6%95%B0/6.4%20inout%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E6%96%B9%E6%B3%95%EF%BC%88inout%20parameter%20and%20mutating%20function%EF%BC%89.md)

#### [6.5 计算属性和下标](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%87%BD%E6%95%B0/6.5%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%B8%8B%E6%A0%87(computed%20property%20and%20subscript).md)

#### [6.6 自动闭包 6.7 总结](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%87%BD%E6%95%B0/6.6%20%E8%87%AA%E5%8A%A8%E9%97%AD%E5%8C%85%20%206.7%20%E6%80%BB%E7%BB%93.md)


### 第七章：字符串


#### [7.1 不再固定宽度](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/7.1%20%E4%B8%8D%E5%86%8D%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6.md)

#### [7.2 字符串和集合](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/7.2%20%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E9%9B%86%E5%90%88.md)

#### [7.3 简单的正则表达式匹配器。 7.4 ExpressibleByStringLiteral](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/7.3%20%E7%AE%80%E5%8D%95%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%99%A8%E3%80%82%20%207.4%20ExpressibleByStringLiteral)

#### [7.5 String的内部结构](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/7.5%20String%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.md)

#### [7.6 编码单元的表示方式](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/7.6%20%E7%BC%96%E7%A0%81%E5%8D%95%E5%85%83%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.md)

#### [7.7 CustomStringConvertible 和 CustomDebugStringConvertible](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/7.7%20CustomStringConvertible%20%E5%92%8C%20CustomDebugStringConvertible.md)

#### [7.8 文本输出流](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/7.8%20%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA%E6%B5%81.md)

#### [7.9 字符串的性能](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/7.9%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%80%A7%E8%83%BD.md)


### 第八章：错误处理

#### [8.1 result类型](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.1%20result%E7%B1%BB%E5%9E%8B.md)

#### [8.2 错误和函数参数](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.2%20%E6%8A%9B%E5%87%BA%E5%92%8C%E6%8D%95%E8%8E%B7.md)

#### [8.3 带有类型的错误](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.3%E5%B8%A6%E6%9C%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%99%E8%AF%AF.md)

#### [8.4 将错误桥接到Objective-C](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.4%20%E5%B0%86%E9%94%99%E8%AF%AF%E6%A1%A5%E6%8E%A5%E5%88%B0Objective-C.md)

#### [8.5 错误和函数参数](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.5%20%E9%94%99%E8%AF%AF%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0.md)
#### [8.6 defer语法可以让代码更简洁](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.6%20defer%E8%AF%AD%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E7%AE%80%E6%B4%81%20Clearing%20Up%20Using%20defer.md)
#### [8.7 错误和可选值](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.7%20%E9%94%99%E8%AF%AF%E5%92%8C%E5%8F%AF%E9%80%89%E5%80%BC%20Error%20and%20Optionals.md)

#### [8.8 错误链](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.8%20%E9%94%99%E8%AF%AF%E9%93%BE.md)
#### [8.9 高阶函数和错误](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.9%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%E9%94%99%E8%AF%AF.md)

### 第九章：泛型


#### [9.1 重载](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%B3%9B%E5%9E%8B/9.1%20%E9%87%8D%E8%BD%BD%20Overloading.md)
#### [9.2 对集合采用泛型操作](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%B3%9B%E5%9E%8B/9.2%20%E5%AF%B9%E9%9B%86%E5%90%88%E9%87%87%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%93%8D%E4%BD%9C%20Operating%20Generically%20on%20Collections.md)
#### [9.3 使用泛型进行代码设计](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%B3%9B%E5%9E%8B/9.3%20%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1Designing%20with%20Generics.md)
#### [9.4 泛型的工作方式](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%B3%9B%E5%9E%8B/9.4%20%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F(How%20Generics%20Work)%20.md)

### 第十章：协议

#### [10.1 面向协议编程](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%8D%8F%E8%AE%AE/10.1%20%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%20Overload%20Resolution%20for%20Free%20Functions%20.md)
#### [10.2 协议的两种类型](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%8D%8F%E8%AE%AE/10.2%20%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%20TwoTypesofProtocols.md)
#### [10.3 带有 Self 的协议](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%8D%8F%E8%AE%AE/10.3%20%E5%B8%A6%E6%9C%89%20Self%20%E7%9A%84%E5%8D%8F%E8%AE%AE%20Protocols%20with%20Self%20Requirements.md)
#### [10.4 协议内幕](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%8D%8F%E8%AE%AE/10.4%20%E5%8D%8F%E8%AE%AE%E5%86%85%E5%B9%95%20Protocol%20Internals.md)

### 第十一章：互用性

#### [11.1 实践:封装 CommonMark](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BA%92%E7%94%A8%E6%80%A7/11.1%20%E5%AE%9E%E8%B7%B5%E5%B0%81%E8%A3%85%20CommonMark.md)
#### [11.2 低层级类型概览](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BA%92%E7%94%A8%E6%80%A7/11.2%20%E4%BD%8E%E5%B1%82%E7%BA%A7%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%A7%88%20%20AnOverviewofLow-LevelTypes.md)
#### [11.3 函数指针](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BA%92%E7%94%A8%E6%80%A7/11.3%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%20%20FunctionPointers%20.md)

#### 全书终🌛🌛
---

## 补充：
## ```关于swift的一些心得和建议:```

# 写在最开始
## 代码规范性
可能有很多同学在一开始写swift代码时都不知道一些相关的代码规范，常量变量如何定义等等。

这里我推荐关于代码规范的三份指导文章， 对于一些同学的```代码规范性```会有很大的提升。


#### [raywenderlich/swift-style-guide   ⭐️10k](https://github.com/raywenderlich/swift-style-guide)

#### [github/swift-style-guide  ⭐️4.5k](https://github.com/github/swift-style-guide)(有中文翻译)

#### [airbnb/swift  ⭐️1k](https://github.com/airbnb/swift)

---
### 代码格式检查工具
我们项目中用的是Realm 团队的[swiftLint](https://github.com/realm/SwiftLint) 
安装比较简单 大部分的```警告```和```Error（不影响运行）```可以给你一些```代码规范的指导```

##### 唯一缺点：会```稍微增加一些编译时间```

公司项目中不改动任何代码的二次编译时间需要```3.82s```

添加swiftLint后时间为```4.279s```，有的时候会更长一些。

##### 如果你只是对代码格式化有要求
##### 推荐使用nicklockwood大神写的[SwiftFormat](https://github.com/nicklockwood/SwiftFormat)
以XCode插件的形式添加到XCode中，一键格式化当前Swift文件。非常方便。

---
## All Tips
### ⭐️tip1: 
#### swift项目```引用OC对象```的坑
##### swift项目引用OC对象时```必须要考虑```该OC象是否可能为nil， ```swift默认引用的OC对象为必选``` 当oc对象为nil就会引起崩溃。
##### 最好在引用OC对象时手动添加一个```?```,将OC对象标记为可选。
在开发过程中有遇到几次崩溃都是没有考虑到这种情况。😿

---
### ⭐️tip2: 
#### 多使用```let```
##### let会让我们在很多时候```放心大胆```的去使用定义好的值，而不用去考虑后面再哪里改变了这个值和安全性的问题。

---
### ⭐️tip3: 
#### 通过```计算型属性```实现```模型的转换```(Objective-C 到 Swift的一个思维转换)
##### 假设App中有一个全局播放器，我们需要把后台发给我们的```不同模块音乐模型```(```ChildrenSongModel```, ```PodcastModel```)转换成```统一的音乐模型```(```GenernalMusicModel```)。

刚刚从Objective-C过渡到Swift时候的我的写法：

    /// 统一音乐模型转换类
    class MusicConvertManager {
        
        /// 将儿歌的音乐模型转换成统一音乐模型
        /// - Parameter childernSongModel: 儿歌模型
        /// - Returns: 统一的音乐模型
        static func convertChildrenSong(of childernSongModel: ChildernSongModel) -> GenernalMusicModel {
            let genernalMusic  = GenernalMusicModel()
            genernalMusic.id   = childernSongModel._id
            genernalMusic.url  = childernSongModel.musicURL
            genernalMusic.name = childernSongModel.title
            return genernalMusic
        }
        
        /// 将播客的音乐模型转换成统一音乐模型
        /// - Parameter childernSongModel: 播客音乐模型
        /// - Returns: 统一的音乐模型
        static func convertChildrenSong(of podcastModel: PodcastModel) -> GenernalMusicModel {
            let genernalMusic  = GenernalMusicModel()
            genernalMusic.id   = PodcastModel.pid
            genernalMusic.url  = childernSongModel.url
            genernalMusic.name = childernSongModel.name
            return genernalMusic
        }

    }

    /// 具体使用   不建议这样，每次写到这里都需要先想到MusicConvertManager类，再思考用哪个具体的方法。❎
    MusicManager.shared.currentModel = MusicConvertManager.convertChildrenSong(of: jsonModel.childrenModel)


建议写法： 通过给具体的模型创建```extension```， 在extension中创建generalMusicModel的```计算型属性```方便阅读和使用。

    /// 通过genernalMusicModel计算型属性转换统一的音乐模型。   PodcastModel转换同理。
    extension ChildernSongModel {
        /// 统一的音乐模型  (如果是耗时操作建议缓存转换后的结果)
        var genernalMusicModel: GenernalMusicModel {
            let genernalMusic  = GenernalMusicModel()
            genernalMusic.id   = _id
            genernalMusic.url  = musicURL
            genernalMusic.name = title
            return genernalMusic
        }
    }

    /// 具体使用 这样写便于阅读及使用方便。 ✅
    MusicManager.shared.currentModel = jsonModel.childrenModel.genernalMusicModel

---
### ⭐️tip4: 
#### 自定义协议如何规范命名？
##### 参考了55个系统API的协议命名规范我们可以把协议命名分三类：

##### 1. 以```able```结尾:  ``` Codable```    表示当前协议可以```添加一个新的功能```。
##### 2. 以```Type```结尾：```CollectionType``` 表示当前协议可以```表示一种类型```。
##### 3. 以```Convertable```结尾：```CustomStringConvertible``` 表示当前协议可以```做类型转换```。
以后有自定义协议的时候，命名可以参照这三种情况去规范命名。

---
### ⭐️tip5: 
#### array.isEmpty 效率比 arrya.count 更高
##### 当我们去判断一个```数组是否为空```的时候 大多都会写if array.count > 0 {} 
##### isEmpty 方法只有检查array```startIndex == endIndex``就可以。而count的底层是```遍历整个array```求集合长度。当数组长度过大时```性能低```一些。

##### 不仅isEmpty效率高，而且会```更安全```
有时候我们判断一个array? 是否为空会写出下面这样代码

    var array:[String]?
    /// 一番array 操作后
    if array?.count != 0 {
        ///当数组长度不为0时
        doSomething()
    } 
    
##### 其实当array为```nil```时 也会走doSomething() 的逻辑   这个时候可能就会出现逻辑上的bug.
##### 用 isEmpty 就不会忽略这样的问题。

---
### ⭐️tip6: 
#### 集合上使用的一些函数式编程的性能提升建议。
##### 上面提到了isEmpty的性能会好于count， 下面会引申一些类似的提升性能的用法。
##### 操作集合我们经常会用到```map```、```filter```、```reduce```等函数，有时候可以使用标准库的其他API使性能提升。


    // 取一个集合中第一个大于0的数
    let numberArray = [-4,1,-1,2,3,9]
    let firstPositiveNumber = numberArray.first(where: { $0 > 0 })    ✅
    
    let firstPositiveNumber = numberArray.filter { $0 > 0 }.first    ❌
    // 第一个方法遍历到符合条件的元素后即停止，  第二个方法在所有元素都遍历完一遍后再去找第一个。
    
    // 同上面还有 取出集合中的最大最小元素
    let minNumber = numberArray.min()    ✅
    let maxNumber = numberArray.max()    ✅

    let minNumber = numberArray.sorted().first    ❌
    let maxNumber = numberArray.sorted().last     ❌

#####  在Swift4.2的时候推出了```allSatisfy(_:)``` 的用法，用于判断是否所有元素满足某一条件。
##### 某些时候可以替换filter。且对于长集合性能提升很大  具体使用场景如下：

    // 判断是不是所有的元素都是大于0   isAllPositive为Bool
    let isAllPositive = numberArray.allSatisfy { $0 > 0 }    ✅✅✅
    
    let isAllPositive = numberArray { $0 > 0 }.isEmpty   ❌❌❌
    // 第一个方法在遇到第一个元素不不符合条件就遍历结束 直接返回false
    // 第二个方法需要把所有的元素都遍历一遍后再去看是否是isEmpty  长集合会性能低下。


#####  判断是否包含一个元素： ```contains```的性能要优于使用```filter(_:)``` 和 ```first(where:)```的用法

    // 判断是否包含 -1 这个元素
    
    let isContiansNagtiveOne = numberArray.contains(-1) ✅
    
    let isContiansNagtiveOne = numberArray.filter { $0 == -1 }.isEmpty == false  ❌
    let isContiansNagtiveOne = numberArray.first(where: { $0 == -1 }) != nil  ❌
    // 其原因同上。

---
### ⭐️tip7: 
#### 将你```时常需要的常量```封装成你需要的属性
##### OC中的宏是我们在之前开发中经常用到的一些常用属性的封装。
##### 在swift中我们可以通过在```extension```中创建一些类属性，让你的常量更优雅
##### SwiftUI标准库中大部分常量都是以这种方式封装。

    extension UIFont {
        /// APP中大标题的字体
        static let appLargeTitle = UIFont.systemFont(ofSize: 24)
    }
    
    extension UIColor {
        /// APP主题色
        static let appMain = UIColor.yellow
    }
    
    let titleLabel = UILabel()
    titleLabel.font = .appLargeTitle
    titleLabel.backgroundColor = .appMain

---
### ⭐️tip8: 
#### 当你需要的返回值有```成功```或者```失败```两种情况，而且```成功或者失败的情况有很多种```的话。推荐你使用Swift5以后推出的```Result```类型。
##### 具体用法可看[之前写过的一篇文章](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/8.1%20result%E7%B1%BB%E5%9E%8B.md)
##### 它会让你的代码变的更简洁清晰。
---
### ⭐️tip9: 
#### 同样在Swift5.0中添加了bool值的新方法```toggle()```， 它的主要作用是让Bool值取反。 
##### 像我们在btn的按钮的状态改变的时候之前一般都会用 ```btn.isSelected = !btn.isSelected``` 有了toggle方法后 直接可以 ```btn.toggle()``` 达到同样的效果。 
---
### ⭐️tip10: 
#### TODO-~~用通俗的语言和使用场景向大家介绍@autoclosure 注解的使用~~  不了解的同学可以先google一下相关用法。
---
### ⭐️tip11: 
#### switch 语句中尽量少的使用```default``` 分支
##### 当我们添加新的case时候 有些没有cover到的地方没有编译报错就会产生一些逻辑错误。
##### 如果觉得编译报错太烦可以使用swift 5 出来的[@unknown](https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E8%99%95%E7%90%86%E6%9C%AA%E4%BE%86-case-%E7%9A%84-unknown-default-swift-5-c064365d6c3) 关键字修饰default 分支  让新添加的case以编译警告的形式出现。
---
### ⭐️tip12: 
#### 打印 枚举的case名，输出并不是枚举的value值而是case的字面名字。
    
    enum Animal: String {
        case human = "H"
        case dog = "D"
        case cat = "C"
    }
    enum TimeUtile: Int {
        case second = 1
        case minute = 60
        case hour = 3600
    }
    
    var animal: Animal = .human
    var time: TimeUtile = .second
    print(animal) // human
    print(animal.rawValue) // H
    print(time) // second
    print(time.rawValue) // 1
---
### ⭐️tip13: 
#### 多用 ```guard let```   少用 ```if let``` 
    
    // 使用 if let 嵌套太多 不利于维护 ❌
    if let realOptionalA = optionalA {
        print("had A")
        if let realOptionalB = optionalB {
            print("had A and B")
            if let realOptionalC = optionalC {
                print("had A、B and C")
            }
        }
    }
    
    // 使用 guard let 调理清楚 便于阅读 ✅
    guard let realOptionalA = optionalA else { return }
    print("had A")
    guard let realOptionalB = optionalB else { return }
    print("had A and B")
    guard let realOptionalC = optionalC else { return }
    print("had A、B and C")
    
#### 多用guard let 去解包可以在很多情况下```大幅度的减小一些耗时函数的编译时间```,具体可以参考[Swift编译加速Tips](https://github.com/Liaoworking/Advanced-Swift/blob/master/swift%E6%96%B0%E7%89%B9%E6%80%A7/Swift%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F%E7%9A%84Tips.md)这篇文章。
    
---
### ⭐️tip14: 
#### 快速为Class生成带有属性的初始化方法

在struct中， 编译器会自动生成带有属性的初始化方法。

    struct User {
        let name: String?
        var age: Int?
    }
    // 可直接调用
    User(name: String?, age: Int?)

但对于class就没有对于的初始化方法。我们可以使用XCode提供的辅助功能来生成对应的初始化方法。

    class Book {
        let name: String?
        let pageCount: Int?
    }

![image](https://github.com/Liaoworking/Advanced-Swift/raw/master/pic/tips_11.png)

    //使用后：
    class Book {
        // 编译器自动补全的方法
        internal init(name: String?, pageCount: Int?) {
            self.name = name
            self.pageCount = pageCount
        }
        
        let name: String?
        let pageCount: Int?
    }

---
### ⭐️tip15: 
#### 自定义enum中尽量不要使用 case none的枚举项。
#### 原因Swift 自带 ```Optional``` 也有一个 case none的枚举。易混淆。

    enum MyEnum {
        case ok
        case error
        case none   ❌
    }
    
    // 这个时候myEnum实际上是一个Optional的枚举值 而Optional 也有一个 none的枚举选项。 
    var myEnum : MyEnum? = .none

    //可以通过指定类型解决 但不建议这样
    var myEnum : MyEnum? = Optional.none
    var myEnum : MyEnum? = MyEnum.none


这个时候编译器会报警告 而且你的switch中会多一个case .some(.none):的选项。

### ⭐️tip16: 
#### 用枚举去定义一些静态的tableView数据源会让代码变的更简洁。
假设某电商app首页的tableView有4个section
   
    // 电商首页的tableView 分组
    //CaseIterable 用来获取枚举项个数
    enum HomeSectionType: Int, CaseIterable {
        // banner位
        case banner = 1
        // 合辑
        case menu = 2
        // 推荐
        case recommend = 3
        // 商品
        case goods = 4
        
        // 枚举内部封装组头高度的计算方法
        var headerHeight: CGFloat {
        switch self :
        case banner:
            return 88.88
            .....
        }
        
    }
  
    // tableView 代理
    func numberOfSections(in tableView: UITableView) -> Int {
        return HomeSectionType.allCases.count
     }
    // 获取组头高度
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {  
        guard let sectionType = HomeSectionType(rawValue: section) else { return 0.0 }
        return sectionType.headerHeight
    }
    
    

这样就可以让tableView的代理看起来简洁明了。
    
```CaseIterable```协议可以让你的枚举具备Array相关的属性，如```count```
还有一个好处就是当产品某个版本想要```调换section的顺序```的时候  可以直接 修改```枚举项的Int值```即可。

Swift中的枚举还有很多很强大的用法，小伙伴们可以在开发过程中自己多尝试一下下~

[更多Tips...](https://github.com/Liaoworking/Advanced-Swift/blob/master/%E5%85%B3%E4%BA%8Eswift%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E5%92%8C%E5%BB%BA%E8%AE%AE%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85.md)

## Contributors List:
maxiaoqing - [https://github.com/maxiaoqing](https://github.com/maxiaoqing)

gitKun - [https://github.com/gitKun](https://github.com/gitKun)


