# 集合类型协议

##  3.4专门的集合类型:Special Collection
对于collection来说，有两个有意思的限制
1.无法将索引后退移动。
2.没有提供插入，移动，替换元素的功能。
虽然只是有一部分集合可以使用他们，但作为标准库。就只写一些通用的方法。


在标准库中有四个针对于collection 补充的协议


        //一个既可以前向又可以后向遍历的集合
        BidirectionalCollection
        //一个可以高效随机存取索引遍历的集合
        RandomAccessCollection
        //一个可以下标赋值的集合
        MutableCollection
        //一个可以将任意子范围的元素用别的集合中的元素进行替换的集合
        RangeReplaceableCollection


#### BidirectionalCollection:
```sufix```， ```removeLast``` 和 ```reversed``` 就是由它来提供。是不是很熟悉


#### RandomAccessCollection
和BidirectionalCollection  ```index(_:offsetBy:)```` 去通过渐进的方式去遍历, 相比 RandomAccessCollection 可以 ```直接在两个索引之间``来移动。
例如计算 startIndex 和 endIndex 的间距。 RandomAccessCollection可以在```常数时间内```计算出count 而其他就会慢很多。

#### MutableCollection
支持原地的元素更改。
只能改变集合的元素值，无法改变``集合的长度``或``元素的顺序``。
MutableCollection 只多了一个required func:
 ```subscript``` 而且要必须提供一个 ```setter```
        
        ///协议方法
        public subscript(position: Self.Index) -> Self.Element { get set }



    public subscript(position: Element) -> Element {
     get {
    return Element 
    } 
    set {
    //必须要提供
    }
    }


注：编译器不会让我们向一个已经存在的Collection通过扩展```添加下标的setter方法``` 原因有二：
1.要提供setter就要提供getter
2.无法重新定义已存在的getter方法
所以我们只能重新写一个协议去替换collection  所以要重新去写getter setter方法。

知识点1：Array Dict Set 中只有```Array```满足这个协议。


#### RangeReplaceableCollection
需要添加或者移除元素可以用这个协议
有两个要求：
1.一个```空的初始化方法```(在泛型函数中很好用，因为泛型允许一个函数创建相同类型的 新的空集合)
2.```replaceSubrange(_:with:)```方法 参数为范围和要替换的集合。


#### 组合能力
我们可以将上面这些特殊的集合协议``组合起来```，来达到我们想要的效果。


# 本章回顾
集合类型主要是由 ```Sequence``` 和 ```Collection``` 协议构成了

###### TODO 内容知识点后期可以更生动形象的写出来

